type bool : Type1 {
    true : bool[]
    false : bool[]
}

type nat : Type1 {
    Z : nat[]
    S : nat[] -> nat[]
}

pred : nat[] -> nat[] := \n : nat[] -> match n as n() in nat[] {
    Z() => nat[].Z,
    S(m) => m
}

fix plus : nat[] -> nat[] -> nat[] := \n : nat[] -> \m : nat[] -> match n as n() in nat[] {
    Z() => m,
    S(n_pred) => nat[].S(plus(n_pred, m))
}

fix minus : nat[] -> nat[] -> nat[] := \n : nat[] -> \m : nat[] -> match n as n() in nat[] {
    Z() => nat[].Z,
    S(n_pred) => minus(n_pred, pred(m))
}

fix mult : nat[] -> nat[] -> nat[] := \n : nat[] -> \m : nat[] -> match n as n() in nat[] {
    Z() => nat[].Z,
    S(n_pred) => plus(mult(n_pred, m), m)
}

type list (A : Type1) : Type1 {
    nil : list[A]
    cons : A -> list[A] -> list[A]
}

char : Type1
string : Type1 := list[char]
