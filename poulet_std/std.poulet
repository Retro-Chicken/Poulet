// define natural number types
nat : Type1 := {X : Type1} (X -> X) -> X -> X
n0 : nat := \X : Type1 -> \f : (X -> X) -> \a : X -> a

// define operations on natural numbers
succ : nat -> nat := \n : nat -> \X : Type1 -> \f : (X -> X) -> \a : X -> f(n(X, f, a))
pred : nat -> nat := \n : nat -> \T : Type1 -> \f : (T -> T) -> \x : T -> n((T -> T) -> T, \g : ((T -> T) -> T) -> \h : (T -> T) -> h(g(f)), \u : (T -> T) -> x)(\u : T -> u)
plus : nat -> nat -> nat := \n : nat -> \m : nat -> \X : Type1 -> \f : (X -> X) -> \a : X -> m(X, f, n(X, f, a))
minus : nat -> nat -> nat := \n : nat -> \m : nat -> m(nat, pred, n)
mult : nat -> nat -> nat := \n : nat -> \m : nat -> \X : Type1 -> \f : (X -> X) -> \a : X -> m(X, n(X, f), a)
exp : nat -> nat -> nat := \n : nat -> \m : nat -> m(nat, mult(n), succ(n0))

// define bools
bool : Type1 := {X : Type1} X -> X -> X
true : bool := \X : Type1 -> \x : X -> \y : X -> x
false : bool := \X : Type1 -> \x : X -> \y : X -> y
ifthenelse : {X : Type1} bool -> X -> X -> X := \X : Type1 -> \p : bool -> \a : X -> \b : X -> p(X, a, b)
and : bool -> bool -> bool := \a : bool -> \b : bool -> ifthenelse(bool, a, b, false)
or : bool -> bool -> bool := \a : bool -> \b : bool -> ifthenelse(bool, a, true, b)
not : bool -> bool := \a : bool -> ifthenelse(bool, a, false, true)
xor : bool -> bool -> bool := \a : bool -> \b : bool -> and(or(a, b), not(and(a, b)))

// predicates on natural numbers
iszero : nat -> bool := \n : nat -> n(bool, \x : bool -> false, true)
geq : nat -> nat -> bool := \n : nat -> \m : nat -> iszero(minus(m, n))
leq : nat -> nat -> bool := \n : nat -> \m : nat -> iszero(minus(n, m))
eq : nat -> nat -> bool := \n : nat -> \m : nat -> and(geq(n, m), geq(m, n))
gtr : nat -> nat -> bool := \n : nat -> \m : nat -> geq(pred(n), m)
less : nat -> nat -> bool := \n : nat -> \m : nat -> leq(succ(n), m)

// integer division
//      dividing by 0 gives dividend
divide : nat -> nat -> nat := \n : nat -> \m : nat -> n(nat, \z : nat -> ifthenelse(nat, leq(mult(m, succ(z)), n), succ(z), z), n0)

// define pairs
pair : Type1 := {X : Type1} (X -> X -> X) -> X
construct_pair : {X : Type1} X -> X -> (pair(X)) := \X : Type1 -> \a : X -> \b : X -> \f : (X -> X -> X) -> f(a, b)
first : {X : Type1} X -> X -> X := \X : Type1 -> true(X)
second : {X : Type1} X -> X -> X := \X : Type1 -> false(X)