type nat : Type1 {
    Z : nat[]
    S : nat[] -> nat[]
}

pred : nat[] -> nat[] := \n : nat[] -> match n as n() in nat[] {
    Z() => nat[].Z,
    S(m) => m
}

fix plus : nat[] -> nat[] -> nat[] := \n : nat[] -> \m : nat[] -> match n as n() in nat[] {
    Z() => m,
    S(n_pred) => nat[].S(plus(n_pred, m))
}

fix minus : nat[] -> nat[] -> nat[] := \n : nat[] -> \m : nat[] -> match n as n() in nat[] {
    Z() => nat[].Z,
    S(n_pred) => minus(n_pred, pred(m))
}

fix mult : nat[] -> nat[] -> nat[] := \n : nat[] -> \m : nat[] -> match n as n() in nat[] {
    Z() => nat[].Z,
    S(n_pred) => plus(mult(n_pred, m), m)
}

type list (A : Type1) : Type1 {
    nil : list[A]
    cons : A -> list[A] -> list[A]
}

/*bool : Type1 := {X : Type1} {_ : X} {_ : X} X
true : bool := \X : Type1 -> \x : X -> \y : X -> x
false : bool := \X : Type1 -> \x : X -> \y : X -> y
ifthenelse : {X : Type1} {_ : bool} {_ : X} {_ : X} X := \X : Type1 -> \p : bool -> \a : X -> \b : X -> (((p) X) a) b
and : {_ : bool} {_ : bool} bool := \a : bool -> \b : bool -> ((((ifthenelse) bool) a) b) false
or : {_ : bool} {_ : bool} bool := \a : bool -> \b : bool -> ((((ifthenelse) bool) a) true) b
not : {_ : bool} bool := \a : bool -> ((((ifthenelse) bool) a) false) true
xor : {_ : bool} {_ : bool} bool := \a : bool -> \b : bool -> ((and) ((or) a) b) (not) ((and) a) b

// predicates on natural numbers
iszero : {_ : nat} bool := \n : nat -> (((n) bool) \x : bool -> false) true
geq : {_ : nat} {_ : nat} bool := \n : nat -> \m : nat -> (iszero) ((minus) m) n
leq : {_ : nat} {_ : nat} bool := \n : nat -> \m : nat -> (iszero) ((minus) n) m
eq : {_ : nat} {_ : nat} bool := \n : nat -> \m : nat -> ((and) ((geq) n) m) ((geq) m) n
gtr : {_ : nat} {_ : nat} bool := \n : nat -> \m : nat -> ((geq) (pred) n) m
less : {_ : nat} {_ : nat} bool := \n : nat -> \m : nat -> ((leq) (succ) n) m

// integer division
//      dividing by 0 gives dividend
divide : {_ : nat} {_ : nat} nat := \n : nat -> \m : nat -> (((n) nat) \z : nat -> ((((ifthenelse) nat) ((leq) ((mult) m) (succ) z) n) (succ) z) z) n0

// define pairs
pair : Type1 := {X : Type1} {_ : {_ : X} {_ : X} X} X
construct_pair : {X : Type1} {_ : X} {_ : X} (pair) X := \X : Type1 -> \a : X -> \b : X -> \f : {_ : X} {_ : X} X -> ((f) a) b
first : {X : Type1} {_ : X} {_ : X} X := \X : Type1 -> (true) X
second : {X : Type1} {_ : X} {_ : X} X := \X : Type1 -> (false) X*/
