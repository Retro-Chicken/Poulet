type bool : Type1 {
    true : bool[]
    false : bool[]
}

ifthenelse : {A : Type1} bool[] -> A -> A -> A
    := \A : Type1 -> \p : bool[] -> \t : A -> \f : A ->
        match p as _() in A {
            true() => t,
            false() => f
        }

type nat : Type1 {
    Z : nat[]
    S : nat[] -> nat[]
}

pred : nat[] -> nat[] := \n : nat[] -> match n as _() in nat[] {
    Z() => nat[].Z,
    S(m) => m
}

fix plus : nat[] -> nat[] -> nat[] := \n : nat[] -> \m : nat[] ->
    match n as _() in nat[] {
        Z() => m,
        S(n_pred) => nat[].S(plus(n_pred, m))
    }

fix minus : nat[] -> nat[] -> nat[] := \n : nat[] -> \m : nat[] ->
    match n as _() in nat[] {
        Z() => nat[].Z,
        S(n_pred) => match m as _() in nat[] {
            Z() => nat[].S(n_pred),
            S(m_pred) => minus(n_pred, m_pred)
        }
    }

fix mult : nat[] -> nat[] -> nat[] := \n : nat[] -> \m : nat[] ->
    match n as _() in nat[] {
        Z() => nat[].Z,
        S(n_pred) => plus(mult(n_pred, m), m)
    }

fix nat_eq : nat[] -> nat[] -> bool[] := \n : nat[] -> \m : nat[] ->
    match n as _() in bool[] {
        Z() => match m as _() in bool[] {
            Z() => bool[].true,
            S(_) => bool[].false
        },
        S(n_pred) => match m as _() in bool[] {
            Z() => bool[].false,
            S(m_pred) => nat_eq(n_pred, m_pred)
        }
    }

geq : nat[] -> nat[] -> bool[] := \n : nat[] -> \m : nat[] ->
    nat_eq(minus(m, n), nat[].Z)

gt : nat[] -> nat[] -> bool[] := \n : nat[] -> \m : nat[] ->
    match n as _() in bool[] {
        Z() => bool[].false,
        S(n_pred) => geq(n_pred, m)
    }

fix div_internal : nat[] -> nat[] -> nat[] -> nat[] :=
    \n : nat[] -> \m : nat[] -> \q : nat[] ->
        match q as _() in nat[] {
           Z() => nat[].Z,
           S(q_pred) => ifthenelse(nat[], geq(n, mult(m, q)))
               (q)
               (div_internal(n, m, q_pred))
        }

// div(n, 0) = n
div : nat[] -> nat[] -> nat[] :=
    \n : nat[] -> \m : nat[] -> div_internal(n, m, n)

fix compose : {A : Type1} nat[] -> (A -> A) -> (A -> A)
    := \A : Type1 -> \n : nat[] -> \f : (A -> A) ->
        match n as _() in A -> A {
            Z() => \x : A -> x,
            S(n_pred) => \x : A -> compose(A, n_pred, f)(f(x))
        }

type list (A : Type1) : Type1 {
    nil : list[A]
    cons : A -> list[A] -> list[A]
}

char : Type1
string : Type1 := list[char]
