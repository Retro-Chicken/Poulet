#import "std_test.poulet"

n0 : nat[] := nat[].Z
n1 : nat[] := nat[].S(nat[].Z)
n2 : nat[] := nat[].S(nat[].S(nat[].Z))
n3 : nat[] := nat[].S(nat[].S(nat[].S(nat[].Z)))

inductive {
    type even : nat[] -> Type1 {
        even_z : even[](nat[].Z)
        even_s : {n : nat[]} odd[](n) -> even[](nat[].S(n))
    }
    type odd : nat[] -> Type1 {
        odd_s : {n : nat[]} even[](n) -> odd[](nat[].S(n))
    }
}

a : even[](n2) := even[].even_s(nat[].S(nat[].Z), odd[].odd_s(nat[].Z, even[].even_z))
b : even[](n0) := even[].even_z

fix nat_ind : {P : nat[] -> Type1} P(nat[].Z) -> ({n : nat[]} P(n) -> P(nat[].S(n))) -> ({n : nat[]} P(n))
    := \P : (nat[] -> Type1) -> \pz : P(nat[].Z) -> \ps : ({n : nat[]} P(n) -> P(nat[].S(n))) -> \n : nat[] ->
        match n as m() in P(m) {
            Z() => pz,
            S(n_pred) => ps(n_pred, nat_ind(P, pz, ps, n_pred))
        }

fix fib : nat[] -> nat[] := \n : nat[] -> match n as _() in nat[] {
    Z() => nat[].Z,
    S(n_pred) => match n_pred as _() in nat[] {
        Z() => nat[].S(nat[].Z),
        S(n_pred_pred) => plus(fib(n_pred_pred), fib(n_pred))
    }
}

fix to_zero : nat[] -> nat[] := \n : nat[] -> match n as _() in nat[] {
    Z() => nat[].Z,
    S(n_pred) => to_zero(n_pred)
}

#assert (\x : _ -> x(n0))(fix {
    t : nat[] -> nat[] := \n : nat[] -> match n as _() in nat[] {
        Z() => nat[].Z,
        S(n_pred) => t(n_pred)
    }
}.t) ~ nat[].Z