inductive {
    type nat : Type1 {
        Z : nat[]
        S : {_ : nat[]} nat[]
    }
}

inductive {
    type list (A : Type1) : Type1 {
        nil : list[A]
        cons : {_ : A} {_ : list[A]} list[A]
    }
}

int : Type1
zero : int
l : list[int] := ((list[int].cons) zero) list[int].nil

#reduce (fix {
    length : {A : Type1} {_ : list[A]} nat[] := \A : Type1 -> \l : list[A] -> match l as l() in nat {
        nil() => nat[].Z,
        cons(h, t) => (nat[].S) ((length) A) t
    }
}.length) l
