bool : Type1 := {X : Type1} {_ : X} {_ : X} X
true : bool := \X : Type1 -> \x : X -> \y : X -> x
false : bool := \X : Type1 -> \x : X -> \y : X -> y

inductive {
    type list (A : Type1) : Type1 {
        nil : list[A]
        cons : {_ : A} {_ : list[A]} list[A]
    }
}

inductive {
    type nat : Type1 {
        Z : nat[]
        S : {_ : nat[]} nat[]
    }
}

inductive {
    type even : {_ : nat[]} Type1 {
        evenZ : (even[]) nat[].Z
        evenS : {n : nat} {_ : (odd[]) n} (even[]) (nat[].S) Z
    }
    type odd : {_ : nat[]} Type1 {
        evenS : {n : nat} {_ : (even[]) n} (odd[]) (nat[].S) Z
    }
}

inductive {
    type and (p : Type1) (q : Type1) : {_ : p} {_ : q} Type1 {
        mk : {_ : p} {_ : q} ((and[p, q]) p) q
    }
}

a : Type1
b : a

#reduce ((and[a, a].mk) b) b